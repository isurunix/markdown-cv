# Copilot Instructions for Markdown CV Builder

## üéØ Project Overview

This is a **modern, markdown-first CV/resume builder** built with Next.js 15, TypeScript, and Tailwind CSS. The application provides real-time markdown editing with live preview and ATS-friendly PDF export capabilities.

### Core Architecture
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS v4 
- **State Management**: Zustand with persistence
- **Editor**: Monaco Editor (@monaco-editor/react)
- **Testing**: Playwright for E2E tests
- **PDF Generation**: Server-side API with Puppeteer

## üõ†Ô∏è Development Best Practices

### 1. Code Organization & Structure

#### Component Structure
```
src/
‚îú‚îÄ‚îÄ app/                    # Next.js App Router pages
‚îú‚îÄ‚îÄ components/             # React components
‚îÇ   ‚îú‚îÄ‚îÄ editor/            # Monaco editor components
‚îÇ   ‚îú‚îÄ‚îÄ preview/           # CV preview components
‚îÇ   ‚îú‚îÄ‚îÄ layout/            # Layout-related components
‚îÇ   ‚îú‚îÄ‚îÄ layouts/           # CV layout templates
‚îÇ   ‚îú‚îÄ‚îÄ templates/         # CV template components
‚îÇ   ‚îî‚îÄ‚îÄ ui/                # Reusable UI components
‚îú‚îÄ‚îÄ lib/                   # Utility functions and configurations
‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îú‚îÄ‚îÄ types/                 # TypeScript type definitions
‚îú‚îÄ‚îÄ constants/             # Application constants
‚îî‚îÄ‚îÄ styles/                # Global styles and CSS modules
```

#### Naming Conventions
- **Components**: PascalCase (e.g., `CVBuilder`, `MarkdownEditor`)
- **Files**: kebab-case for utilities, PascalCase for components
- **Functions**: camelCase (e.g., `handleExport`, `validateInput`)
- **Constants**: SCREAMING_SNAKE_CASE (e.g., `DEFAULT_CV_CONTENT`)
- **Types**: PascalCase with descriptive names (e.g., `CVState`, `TemplateConfig`)

### 2. TypeScript Guidelines

#### Type Safety Rules
- Always use strict TypeScript mode
- Define interfaces for all props and state objects
- Use type guards for runtime validation
- Prefer `interface` over `type` for object shapes
- Use `const assertions` for immutable data

#### Example Type Definitions
```typescript
// Good: Descriptive and specific
interface CVTemplateProps {
  content: string;
  layout: 'single-column' | 'two-column';
  template: TemplateConfig;
  className?: string;
}

// Avoid: Generic or vague types
interface Props {
  data: any;
  config: object;
}
```

### 3. React Component Best Practices

#### Component Design Principles
- **Single Responsibility**: Each component should have one clear purpose
- **Composition over Inheritance**: Use composition patterns
- **Props Interface**: Always define explicit prop interfaces
- **Default Props**: Use ES6 default parameters
- **Error Boundaries**: Implement for critical components

#### Component Template
```typescript
interface ComponentNameProps {
  // Required props
  requiredProp: string;
  // Optional props with defaults
  optionalProp?: boolean;
  // Event handlers
  onAction?: (value: string) => void;
  // Children or className for extensibility
  children?: React.ReactNode;
  className?: string;
}

export function ComponentName({ 
  requiredProp, 
  optionalProp = false,
  onAction,
  children,
  className 
}: ComponentNameProps) {
  // Component logic here
  return (
    <div className={cn("base-styles", className)}>
      {/* Component JSX */}
    </div>
  );
}
```

### 4. State Management with Zustand

#### Store Structure
- Keep stores focused and domain-specific
- Use middleware for persistence and devtools
- Implement proper TypeScript interfaces
- Avoid deep nesting in store state

#### Store Best Practices
```typescript
interface StoreState {
  // State
  data: SomeType;
  loading: boolean;
  error: string | null;
  
  // Actions (always use descriptive names)
  setData: (data: SomeType) => void;
  updateData: (updates: Partial<SomeType>) => void;
  clearError: () => void;
  reset: () => void;
}
```

### 5. Styling Guidelines

#### Tailwind CSS Best Practices
- Use design tokens consistently (spacing, colors, typography)
- Create reusable component classes
- Implement responsive design mobile-first
- Use CSS variables for theming
- Group related utilities together

#### CSS Organization
```typescript
// Good: Organized and readable
const buttonStyles = cn(
  // Base styles
  "inline-flex items-center justify-center",
  "px-4 py-2 text-sm font-medium",
  "border border-transparent rounded-md",
  // Interactive states
  "hover:opacity-90 focus:outline-none focus:ring-2",
  "disabled:opacity-50 disabled:cursor-not-allowed",
  // Variants
  variant === 'primary' && "bg-blue-600 text-white",
  variant === 'secondary' && "bg-gray-200 text-gray-900"
);
```

### 6. PDF Generation Guidelines

#### Server-Side PDF Generation with Puppeteer
- **Architecture**: Client sends HTML ‚Üí API route with Puppeteer ‚Üí PDF blob response
- **API Route**: `/api/generate-pdf` handles PDF generation
- **Format Support**: A4 and US Letter page formats
- **Quality Modes**: Standard (high quality) and ATS (optimized for parsing)

#### PDF Generation Best Practices
```typescript
// Good: Proper error handling and resource cleanup
export async function generatePDF(element: HTMLElement, options: PDFOptions) {
  try {
    const htmlContent = extractHTMLContent(element);
    const response = await fetch('/api/generate-pdf', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ html: htmlContent, options })
    });
    
    if (!response.ok) throw new Error(`PDF generation failed: ${response.status}`);
    return await response.blob();
  } catch (error) {
    console.error('PDF generation error:', error);
    throw error;
  }
}
```

#### CSS for PDF Generation
- Use absolute units (px, pt) over relative units (rem, em)
- Ensure proper `print-color-adjust: exact` for backgrounds
- Test with both page formats (A4 vs US Letter)
- Avoid CSS transforms and absolute positioning
- Use standard fonts for better compatibility

## üîÑ Git Workflow & Incremental Development

### **CRITICAL RULE: Always Make Small, Focused Changes**

#### Commit Guidelines
- **One feature per commit**: Never bundle multiple features
- **Atomic commits**: Each commit should be a complete, working change
- **Descriptive messages**: Use conventional commit format
- **Test before commit**: Ensure all tests pass locally

#### Conventional Commit Format
```
type(scope): description

feat(editor): add markdown syntax highlighting
fix(export): resolve PDF generation memory leak
docs(readme): update installation instructions
refactor(store): simplify state management logic
test(preview): add component rendering tests
style(ui): improve button component styling
```

#### Recommended Change Sizes
- ‚úÖ **Single component modification** (50-100 lines)
- ‚úÖ **New utility function** (20-50 lines)
- ‚úÖ **Bug fix with test** (10-30 lines)
- ‚úÖ **Type definition updates** (5-20 lines)
- ‚ùå **Multiple component refactor** (300+ lines)
- ‚ùå **Cross-cutting architecture changes**
- ‚ùå **Bundle dependency updates**

### Git Workflow Steps
1. **Create feature branch** from main
2. **Make small, focused change**
3. **Test locally** (`npm run build`, `npm run lint`)
4. **Commit with clear message**
5. **Push to feature branch**
6. **Create pull request** with description
7. **Review and merge**

## üìù Code Quality Standards

### ESLint Configuration
- Follow Next.js and TypeScript recommended rules
- Enforce consistent code formatting
- Catch potential bugs and code smells
- Use TypeScript-aware linting rules

### Testing Strategy
- **E2E Tests**: Use Playwright for critical user journeys
- **Component Tests**: Test component behavior and props
- **Utility Tests**: Test helper functions and business logic
- **Type Tests**: Verify TypeScript type safety

### Performance Guidelines
- Use Next.js Image component for optimized images
- Implement code splitting for large components
- Minimize bundle size with dynamic imports
- Use React.memo for expensive re-renders
- Optimize Zustand selectors to prevent unnecessary re-renders

## üö´ What NOT to Do

### Avoid These Patterns
- ‚ùå **Large, monolithic components** (>200 lines)
- ‚ùå **Global state for everything** (use local state when appropriate)
- ‚ùå **Inline styles** (use Tailwind classes)
- ‚ùå **Any type usage** (always define proper types)
- ‚ùå **Mutating props or state directly**
- ‚ùå **Console.log in production code**
- ‚ùå **Hardcoded strings** (use constants)
- ‚ùå **Nested ternary operators** (use early returns or separate functions)

### Refactoring Red Flags
- Components over 200 lines
- Functions with more than 5 parameters
- Deeply nested conditional logic (>3 levels)
- Duplicate code patterns
- Hard-to-test functions

## üé® Feature Development Guidelines

### Adding New Features
1. **Plan the API**: Define TypeScript interfaces first
2. **Start small**: Implement minimal viable version
3. **Add tests**: Write tests as you develop
4. **Iterate**: Make small improvements incrementally
5. **Document**: Update README and docs

### Feature Branch Workflow
```bash
# Create feature branch
git checkout -b feat/add-new-template

# Make small change
# Add new template type definition
git add src/types/cv.ts
git commit -m "feat(types): add modern template interface"

# Implement template component
git add src/components/templates/ModernTemplate.tsx
git commit -m "feat(templates): add modern template component"

# Add template to selector
git add src/components/ui/TemplateSelector.tsx
git commit -m "feat(ui): integrate modern template in selector"

# Push and create PR
git push origin feat/add-new-template
```

## üêõ Bug Fix Process

### Bug Fix Workflow
1. **Reproduce the issue** locally
2. **Write a failing test** that demonstrates the bug
3. **Fix the minimum code** to make test pass
4. **Verify fix** doesn't break existing functionality
5. **Commit with clear description** of fix

### Example Bug Fix Commit
```
fix(pdf): resolve memory leak in PDF generation

- Add proper cleanup of canvas elements
- Implement memory management for large documents
- Add warning for documents over 10 pages

Fixes #123
```

## üìö Learning Resources

### Project-Specific
- Next.js App Router documentation
- Zustand state management patterns
- Monaco Editor API reference
- Tailwind CSS design system
- Playwright testing best practices
- Puppeteer PDF generation guide

### General Best Practices
- React TypeScript patterns
- Git conventional commits
- Component composition patterns
- Performance optimization techniques

## üéØ Success Metrics

### Code Quality Indicators
- TypeScript compilation without errors
- ESLint passes without warnings
- All tests pass (E2E and unit)
- Bundle size remains under threshold
- Component render performance maintained

### Development Velocity
- Small, frequent commits (multiple per day)
- Clear, descriptive commit messages
- Fast feedback loop (local testing)
- Minimal merge conflicts
- Quick review cycles

---

## üí° Quick Reference

### Common Commands
```bash
# Development
npm run dev                 # Start development server
npm run build              # Build for production
npm run lint               # Run ESLint
npm run test:e2e          # Run Playwright tests

# Git workflow
git checkout -b feat/feature-name
git add .
git commit -m "feat(scope): description"
git push origin feat/feature-name
```

### File Patterns
- Components: `src/components/[category]/ComponentName.tsx`
- Types: `src/types/domain.ts`
- Utils: `src/lib/utility-name.ts`
- Tests: `tests/e2e/feature.spec.ts`

Remember: **Small changes, clear commits, thorough testing**. Every change should be reviewable, testable, and reversible.
